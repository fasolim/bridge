require('dotenv').config();
const express = require('express');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

const app = express();
app.use(express.json());

// Configura√ß√£o
const TASKS_DIR = path.join(__dirname, 'tasks');
const RESULTS_DIR = path.join(__dirname, 'results');
const PROJECTS_DIR = path.join(__dirname, 'projects');

// Cria diret√≥rios necess√°rios
if (!fs.existsSync(TASKS_DIR)) fs.mkdirSync(TASKS_DIR);
if (!fs.existsSync(RESULTS_DIR)) fs.mkdirSync(RESULTS_DIR);
if (!fs.existsSync(PROJECTS_DIR)) fs.mkdirSync(PROJECTS_DIR);

// Helper: Busca projeto/subprojeto na pasta projects/
function findProjectPath(projectName, subProject) {
  if (!projectName) return null;
  
  const cleanName = projectName.toLowerCase().trim();
  const cleanSub = subProject ? subProject.toLowerCase().trim() : null;
  
  // Lista projetos principais
  const mainProjects = fs.readdirSync(PROJECTS_DIR)
    .filter(f => fs.statSync(path.join(PROJECTS_DIR, f)).isDirectory());
  
  // Busca projeto principal
  let mainFound = mainProjects.find(p => p.toLowerCase() === cleanName || p.toLowerCase().includes(cleanName));
  
  if (!mainFound) return null;
  
  const mainPath = path.join(PROJECTS_DIR, mainFound);
  
  // Se n√£o tem subprojeto, retorna o principal
  if (!cleanSub) return mainPath;
  
  // Busca subprojeto dentro do principal
  try {
    const subProjects = fs.readdirSync(mainPath)
      .filter(f => fs.statSync(path.join(mainPath, f)).isDirectory());
    
    const subFound = subProjects.find(s => 
      s.toLowerCase() === cleanSub || 
      s.toLowerCase().includes(cleanSub) ||
      (cleanSub.includes('front') && s.toLowerCase().includes('front')) ||
      (cleanSub.includes('back') && s.toLowerCase().includes('back'))
    );
    
    if (subFound) return path.join(mainPath, subFound);
  } catch (err) {
    console.log('‚ö†Ô∏è Erro ao buscar subprojeto:', err.message);
  }
  
  // Se n√£o encontrou subprojeto, retorna o principal
  return mainPath;
}

// Helper: Abre arquivo no Cursor e envia automaticamente para o chat
async function openInCursor(filePath) {
  return new Promise((resolve) => {
    const cursorCommand = `cursor "${filePath}"`;
    
    exec(cursorCommand, (error) => {
      if (error) {
        console.log('‚ö†Ô∏è  N√£o foi poss√≠vel abrir automaticamente no Cursor');
        console.log('üëâ Abra manualmente:', filePath);
        resolve(false);
      } else {
        console.log('‚úÖ Arquivo aberto no Cursor!');
        console.log('ü§ñ Enviando para o chat automaticamente...');
        
        // Aguarda 3 segundos para o Cursor carregar
        setTimeout(() => {
          const chatMessage = `Busque todos os bugs com Status 'Reprovado' e os  no database do Notion. Para cada bug: analise o problema, implemente a solu√ß√£o no c√≥digo tanto back quanto front se necess√°rio, fa√ßa commit no GitHub com mensagem 'fix: [t√≠tulo do bug]', e atualize o status do bug para 'Pronto para teste' no Notion com a solu√ß√£o implementada e o hash do commit. ${path.basename(filePath)}. N√£o pe√ßa confirma√ß√£o, apenas execute agora de forma aut√¥noma e completa.`;
          
          // Tenta enviar via PowerShell
          const psScript = path.join(__dirname, 'auto-chat.ps1');
          const psCommand = `powershell -ExecutionPolicy Bypass -File "${psScript}" -Message "${chatMessage.replace(/"/g, '\\"')}"`;
          
          exec(psCommand, (psError) => {
            if (psError) {
              console.log('');
              console.log('‚ö†Ô∏è  N√£o foi poss√≠vel enviar automaticamente para o chat');
              console.log('');
              console.log('üìã COPIE E COLE NO CHAT (Ctrl+L):');
              console.log('‚îÄ'.repeat(70));
              console.log(chatMessage);
              console.log('‚îÄ'.repeat(70));
              console.log('');
            } else {
              console.log('');
              console.log('‚ïê'.repeat(70));
              console.log('‚úÖ MENSAGEM ENVIADA AUTOMATICAMENTE PARA O CHAT!');
              console.log('‚ïê'.repeat(70));
              console.log('');
              console.log('ü§ñ O Cursor AI deve come√ßar a executar agora...');
              console.log('');
            }
          });
        }, 3000);
        
        resolve(true);
      }
    });
  });
}

// Helper: Lista todos os projetos e subprojetos dispon√≠veis
function listAvailableProjects() {
  try {
    const projects = [];
    const mainDirs = fs.readdirSync(PROJECTS_DIR)
      .filter(f => fs.statSync(path.join(PROJECTS_DIR, f)).isDirectory());
    
    mainDirs.forEach(main => {
      const mainPath = path.join(PROJECTS_DIR, main);
      projects.push({ name: main, path: mainPath, type: 'main' });
      
      // Lista subprojetos
      try {
        const subDirs = fs.readdirSync(mainPath)
          .filter(f => fs.statSync(path.join(mainPath, f)).isDirectory());
        
        subDirs.forEach(sub => {
          projects.push({
            name: `${main}/${sub}`,
            path: path.join(mainPath, sub),
            type: 'sub',
            parent: main
          });
        });
      } catch (err) {
        // Ignora se n√£o conseguir ler subpastas
      }
    });
    
    return projects;
  } catch {
    return [];
  }
}

// Fun√ß√£o para gerar um arquivo de tarefa para o Cursor processar
function createTaskFile(taskData) {
  const taskId = `task-${Date.now()}`;
  const taskFile = path.join(TASKS_DIR, `${taskId}.json`);
  
  const taskContent = {
    id: taskId,
    timestamp: new Date().toISOString(),
    status: 'pending',
    data: taskData,
    instructions: generateInstructions(taskData)
  };
  
  fs.writeFileSync(taskFile, JSON.stringify(taskContent, null, 2));
  
  // Cria arquivo de instru√ß√£o em markdown para o Cursor ler
  const instructionFile = path.join(TASKS_DIR, `${taskId}-INSTRUCTIONS.md`);
  
  // Cria conte√∫do com trigger para auto-execu√ß√£o
  const autoExecuteContent = `# üö® EXECU√á√ÉO AUTOM√ÅTICA DETECTADA

${taskContent.instructions}

---

## üí¨ MENSAGEM AUTOM√ÅTICA PARA O CURSOR AI

**Busque todos os bugs com Status 'Reprovado' e os  no database do Notion. Para cada bug: analise o problema, implemente a solu√ß√£o no c√≥digo tanto back quanto front se necess√°rio, fa√ßa commit no GitHub com mensagem 'fix: [t√≠tulo do bug]', e atualize o status do bug para 'Pronto para teste' no Notion com a solu√ß√£o implementada e o hash do commit.**

**N√£o pe√ßa confirma√ß√£o. Apenas execute agora.**

---`;

  fs.writeFileSync(instructionFile, autoExecuteContent);
  
  console.log(`üìù Tarefa criada: ${taskId}`);
  console.log(`üìÑ Arquivo: ${instructionFile}`);
  
  // Cria arquivo .cursorignore tempor√°rio para for√ßar detec√ß√£o
  const cursorTrigger = path.join(TASKS_DIR, '.cursor-auto-execute');
  fs.writeFileSync(cursorTrigger, `${taskId}\n${new Date().toISOString()}`);
  
  return { taskId, taskFile, instructionFile };
}

// Gera as instru√ß√µes completas para o Cursor executar
function generateInstructions(data) {
  const { notionDatabaseUrl, projectPath, projectContext, githubRepo, autoCommit } = data;
  
  return `# ü§ñ TAREFA AUTOM√ÅTICA - BUG RESOLVER

**Status**: PENDENTE  
**Criado em**: ${new Date().toLocaleString('pt-BR')}

---

## üìã CONTEXTO DO PROJETO

**Projeto**: ${projectPath}
**Tipo**: ${projectContext || 'N√£o especificado'}
${githubRepo ? `**Reposit√≥rio**: ${githubRepo}` : ''}

---

## üéØ MISS√ÉO

Voc√™ deve executar automaticamente os seguintes passos:

### PASSO 1: Buscar Bugs no Notion

Use o MCP do Notion para buscar todos os bugs com status "Pendente" no banco de dados:

\`\`\`
Database URL: ${notionDatabaseUrl}
\`\`\`

**Comando para voc√™ executar:**
- Use a ferramenta \`mcp_Notion_notion-search\` ou \`mcp_Notion_notion-fetch\`
- Busque por p√°ginas com status = "Pendente"
- Extraia: ID, Nome, Descri√ß√£o, Prioridade

### PASSO 2: Para Cada Bug Encontrado

Para cada bug pendente, execute:

#### 2.1. An√°lise do Bug
- Leia a descri√ß√£o completa
- Identifique o tipo de problema
- Determine quais arquivos podem estar envolvidos

#### 2.2. Busca no C√≥digo
- Navegue at√©: \`${projectPath}\`
- Use \`codebase_search\` para encontrar c√≥digo relacionado
- Identifique o arquivo e linha com problema

#### 2.3. Implementa√ß√£o da Corre√ß√£o
- Abra o arquivo problem√°tico
- Analise o c√≥digo atual
- Implemente a corre√ß√£o adequada
- Garanta que segue as boas pr√°ticas
- N√ÉO quebre funcionalidades existentes

#### 2.4. Valida√ß√£o
- Se houver testes, execute-os
- Verifique se a corre√ß√£o resolve o bug
- Confirme que n√£o criou novos problemas

${autoCommit !== false ? `
#### 2.5. Commit (Autom√°tico)
- Fa√ßa commit das altera√ß√µes com mensagem clara:
  - Formato: \`fix: [nome do bug]\`
  - Body: descri√ß√£o da corre√ß√£o implementada
- Se configurado, fa√ßa push para o reposit√≥rio
` : ''}

#### 2.6. Atualiza√ß√£o no Notion
- Use o MCP do Notion para atualizar o bug
- Altere o status para "Resolvido"
- Adicione um coment√°rio com:
  - Descri√ß√£o da corre√ß√£o
  - Arquivos alterados
  ${autoCommit !== false ? '- Hash do commit' : ''}

### PASSO 3: Relat√≥rio Final

Crie um arquivo em \`results/relatorio-${Date.now()}.md\` com:
- Total de bugs processados
- Lista de bugs resolvidos
- Arquivos alterados
- Commits feitos (se houver)
- Bugs que n√£o puderam ser resolvidos (com motivo)

---

## ‚ö†Ô∏è REGRAS IMPORTANTES

1. **SEMPRE** analise o c√≥digo antes de fazer altera√ß√µes
2. **NUNCA** delete c√≥digo sem entender sua fun√ß√£o
3. **SEMPRE** mantenha o estilo de c√≥digo do projeto
4. **NUNCA** fa√ßa commit se os testes falharem
5. **SEMPRE** atualize o Notion ap√≥s resolver um bug
6. **SE** n√£o conseguir resolver um bug, marque como "Em An√°lise" e adicione coment√°rio explicando o bloqueio

---

## üöÄ EXECUTE AGORA

**IMPORTANTE**: Voc√™ deve come√ßar a executar IMEDIATAMENTE ap√≥s ler este arquivo.

N√£o pe√ßa confirma√ß√£o, n√£o espere aprova√ß√£o. Execute de forma aut√¥noma e completa.

Boa sorte! üéØ
`;
}

// Fun√ß√£o principal que processa a requisi√ß√£o
async function processBugResolverRequest(requestData) {
  console.log('\n' + '='.repeat(70));
  console.log('ü§ñ BUG RESOLVER - PROCESSAMENTO AUTOM√ÅTICO');
  console.log('='.repeat(70));
  console.log(`\nüìÖ Iniciado em: ${new Date().toLocaleString('pt-BR')}\n`);
  
  let {
    notionDatabaseUrl,
    projectPath,
    projectName,
    subProject,
    projectContext,
    githubRepo,
    autoCommit = true
  } = requestData;
  
  // Valida√ß√µes
  if (!notionDatabaseUrl) {
    throw new Error('notionDatabaseUrl √© obrigat√≥rio');
  }
  
  // Se n√£o passou projectPath, tenta buscar pelo nome
  if (!projectPath && projectName) {
    projectPath = findProjectPath(projectName, subProject);
    if (!projectPath) {
      const available = listAvailableProjects();
      throw new Error(`Projeto "${projectName}${subProject ? '/' + subProject : ''}" n√£o encontrado. Dispon√≠veis: ${available.map(p => p.name).join(', ')}`);
    }
    console.log(`‚úÖ Projeto encontrado: ${projectPath}`);
  }
  
  if (!projectPath) {
    const available = listAvailableProjects();
    throw new Error(`projectPath ou projectName √© obrigat√≥rio. Projetos dispon√≠veis: ${available.map(p => p.name).join(', ')}`);
  }
  
  console.log('üìã Configura√ß√£o recebida:');
  console.log(`   üìä Notion Database: ${notionDatabaseUrl}`);
  console.log(`   üìÅ Projeto: ${projectPath}`);
  console.log(`   üí° Contexto: ${projectContext || 'N√£o especificado'}`);
  console.log(`   üîÑ Auto Commit: ${autoCommit ? 'Sim' : 'N√£o'}`);
  if (githubRepo) console.log(`   üåê GitHub: ${githubRepo}`);
  
  // Cria arquivo de tarefa
  console.log('\nüìù Criando tarefa para execu√ß√£o autom√°tica...\n');
  const task = createTaskFile(requestData);
  
  console.log('‚úÖ Tarefa criada com sucesso!');
  console.log('\nü§ñ Abrindo automaticamente no Cursor...\n');
  
  // Tenta abrir automaticamente no Cursor
  const opened = await openInCursor(task.instructionFile);
  
  return {
    success: true,
    taskId: task.taskId,
    instructionFile: task.instructionFile,
    autoOpened: opened,
    message: opened 
      ? '‚úÖ Tarefa criada e aberta no Cursor!' 
      : '‚úÖ Tarefa criada! Abra manualmente no Cursor.',
    nextSteps: opened 
      ? [
          '‚úÖ Arquivo aberto no Cursor',
          'Aguarde a execu√ß√£o autom√°tica',
          'Verifique o relat√≥rio em results/'
        ]
      : [
          `Abra o arquivo: ${task.instructionFile}`,
          'Execute as instru√ß√µes automaticamente',
          'Verifique o relat√≥rio em results/'
        ]
  };
}

// Endpoint principal para iniciar resolu√ß√£o de bugs
app.post('/api/bug-resolver', async (req, res) => {
  try {
    // Aceita tanto os novos par√¢metros quanto os antigos (compatibilidade)
    const requestData = {
      notionDatabaseUrl: req.body.notionDatabaseUrl || req.body.databaseUrl,
      projectPath: req.body.projectPath,
      projectName: req.body.projectName,
      subProject: req.body.subProject,
      projectContext: req.body.projectContext || req.body.prompt,
      githubRepo: req.body.githubRepo,
      autoCommit: req.body.autoCommit !== false
    };
    
    const result = await processBugResolverRequest(requestData);
    
    res.json(result);
    
  } catch (error) {
    console.error('‚ùå Erro:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      help: 'Verifique se notionDatabaseUrl e projectPath foram fornecidos'
    });
  }
});

// Endpoint para listar tarefas
app.get('/api/tasks', (req, res) => {
  try {
    const tasks = fs.readdirSync(TASKS_DIR)
      .filter(f => f.endsWith('.json'))
      .map(f => {
        const content = fs.readFileSync(path.join(TASKS_DIR, f), 'utf8');
        return JSON.parse(content);
      })
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    res.json({
      success: true,
      total: tasks.length,
      tasks: tasks
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para ver relat√≥rios
app.get('/api/results', (req, res) => {
  try {
    const results = fs.readdirSync(RESULTS_DIR)
      .map(f => ({
        name: f,
        path: path.join(RESULTS_DIR, f),
        created: fs.statSync(path.join(RESULTS_DIR, f)).birthtime
      }))
      .sort((a, b) => b.created - a.created);
    
    res.json({
      success: true,
      total: results.length,
      results: results
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para listar projetos dispon√≠veis
app.get('/api/projects', (req, res) => {
  try {
    const projects = listAvailableProjects();
    
    res.json({
      success: true,
      total: projects.length,
      projects: projects
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

const PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || '0.0.0.0'; // Aceita conex√µes de qualquer IP

// Fun√ß√£o para obter o IP local da m√°quina
function getLocalIP() {
  const { networkInterfaces } = require('os');
  const nets = networkInterfaces();
  
  for (const name of Object.keys(nets)) {
    for (const net of nets[name]) {
      // Pula endere√ßos internos e n√£o-IPv4
      if (net.family === 'IPv4' && !net.internal) {
        return net.address;
      }
    }
  }
  return 'localhost';
}

app.listen(PORT, HOST, () => {
  const localIP = getLocalIP();
  
  console.log('\n' + '='.repeat(70));
  console.log('üöÄ Bug Resolver API est√° rodando!');
  console.log('='.repeat(70));
  console.log(`\nüì° URLs dispon√≠veis:\n`);
  console.log(`   Local:    http://localhost:${PORT}/api/bug-resolver`);
  console.log(`   Rede:     http://${localIP}:${PORT}/api/bug-resolver`);
  console.log(`\nüìå Use o endere√ßo de REDE para acessar de outros computadores`);
  console.log('='.repeat(70) + '\n');
});